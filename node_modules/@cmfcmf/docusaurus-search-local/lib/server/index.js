"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateOptions = void 0;
const tslib_1 = require("tslib");
const fs_1 = (0, tslib_1.__importDefault)(require("fs"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const util_1 = (0, tslib_1.__importDefault)(require("util"));
const utils_1 = require("@docusaurus/utils");
const lunr_1 = (0, tslib_1.__importDefault)(require("lunr"));
const utils_validation_1 = require("@docusaurus/utils-validation");
const readFileAsync = util_1.default.promisify(fs_1.default.readFile);
const writeFileAsync = util_1.default.promisify(fs_1.default.writeFile);
const parse_1 = require("./parse");
const logger_1 = (0, tslib_1.__importDefault)(require("./logger"));
// FIXME: Duplicated in src/theme/SearchBar/util.js
function urlMatchesPrefix(url, prefix) {
    if (prefix.endsWith("/")) {
        throw new Error(`prefix must not end with a /. This is a bug.`);
    }
    return prefix === "" || url === prefix || url.startsWith(`${prefix}/`);
}
const languageSchema = utils_validation_1.Joi.string().valid("ar", "da", "de", "en", "es", "fi", "fr", "hi", "hu", "it", "ja", "nl", "no", "pt", "ro", "ru", "sv", "th", "tr", "vi", "zh");
const basePathSchema = utils_validation_1.Joi.string().pattern(/^\//);
const optionsSchema = utils_validation_1.Joi.object({
    indexDocs: utils_validation_1.Joi.boolean().default(true),
    docsRouteBasePath: basePathSchema.default("/docs"),
    indexDocSidebarParentCategories: utils_validation_1.Joi.number()
        .integer()
        .min(0)
        .max(Number.MAX_SAFE_INTEGER)
        .default(0),
    indexBlog: utils_validation_1.Joi.boolean().default(true),
    blogRouteBasePath: basePathSchema.default("/blog"),
    indexPages: utils_validation_1.Joi.boolean().default(false),
    language: utils_validation_1.Joi.alternatives(languageSchema, utils_validation_1.Joi.array().items(languageSchema)).default("en"),
    style: utils_validation_1.Joi.string().valid("none"),
    lunr: utils_validation_1.Joi.object({
        tokenizerSeparator: utils_validation_1.Joi.object().regex(),
    }).default(),
});
function cmfcmfDocusaurusSearchLocal(context, options) {
    let { language, blogRouteBasePath: blogBasePath, docsRouteBasePath: docsBasePath, indexDocSidebarParentCategories, indexBlog, indexDocs, indexPages, style, lunr: { tokenizerSeparator: lunrTokenizerSeparator }, } = options;
    if (lunrTokenizerSeparator) {
        // @ts-expect-error
        lunr_1.default.tokenizer.separator = lunrTokenizerSeparator;
    }
    if (Array.isArray(language) && language.length === 1) {
        language = language[0];
    }
    blogBasePath = blogBasePath.substr(1);
    docsBasePath = docsBasePath.substr(1);
    const docsDir = path_1.default.resolve(context.siteDir, "docs");
    let docVersions = [];
    let useDocVersioning = false;
    if (!fs_1.default.existsSync(docsDir)) {
        logger_1.default.info(`Skipping search index generation for documentation because directory ${docsDir} does not exist.`);
    }
    else {
        const versionsPath = path_1.default.join(docsDir, "..", "versions.json");
        if (fs_1.default.existsSync(versionsPath)) {
            useDocVersioning = true;
            docVersions = [
                ...JSON.parse(fs_1.default.readFileSync(versionsPath, "utf-8")),
                "next",
            ];
            logger_1.default.info(`The following documentation versions were detected: ${docVersions.join(", ")}`);
        }
        else {
            logger_1.default.info(`The documentation is not versioned (${versionsPath} does not exist).`);
        }
    }
    let generated = "// THIS FILE IS AUTOGENERATED\n" + "// DO NOT EDIT THIS FILE!\n\n";
    if (style !== "none") {
        generated += 'require("@algolia/autocomplete-theme-classic");\n';
        generated += 'import "./index.css";\n';
    }
    generated += 'import * as lunr from "lunr";\n';
    function handleLangCode(code) {
        let generated = "";
        if (code === "jp") {
            throw new Error(`Language "jp" is deprecated, please use "ja".`);
        }
        if (code === "ja") {
            require("lunr-languages/tinyseg")(lunr_1.default);
            generated += `require("lunr-languages/tinyseg")(lunr);\n`;
        }
        else if (code === "th" || code === "hi") {
            // @ts-expect-error see
            // https://github.com/MihaiValentin/lunr-languages/blob/a62fec97fb1a62bb4581c9b69a5ddedf62f8f62f/test/VersionsAndLanguagesTest.js#L110-L112
            lunr_1.default.wordcut = require("lunr-languages/wordcut");
            generated += `lunr.wordcut = require("lunr-languages/wordcut");\n`;
        }
        require(`lunr-languages/lunr.${code}`)(lunr_1.default);
        generated += `require("lunr-languages/lunr.${code}")(lunr);\n`;
        return generated;
    }
    if (language !== "en") {
        require("lunr-languages/lunr.stemmer.support")(lunr_1.default);
        generated += 'require("lunr-languages/lunr.stemmer.support")(lunr);\n';
        if (Array.isArray(language)) {
            language
                .filter((code) => code !== "en")
                .forEach((code) => {
                generated += handleLangCode(code);
            });
            require("lunr-languages/lunr.multi")(lunr_1.default);
            generated += `require("lunr-languages/lunr.multi")(lunr);\n`;
        }
        else {
            generated += handleLangCode(language);
        }
    }
    if (language === "zh") {
        // nodejieba does not run in the browser, so we need to use a custom tokenizer here.
        // FIXME: We should look into compiling nodejieba to WebAssembly and use that instead.
        generated += `\
export const tokenize = (input) => input.trim().toLowerCase()
  .split(${(lunrTokenizerSeparator
            ? lunrTokenizerSeparator
            : /[\s\-]+/).toString()})
  .filter(each => !!each);\n`;
    }
    else if (language === "ja" || language === "th") {
        if (lunrTokenizerSeparator) {
            throw new Error("The lunr.tokenizerSeparator option is not supported for 'ja' and 'th'");
        }
        generated += `\
export const tokenize = (input) => lunr[${JSON.stringify(language)}].tokenizer(input)
  .map(token => token${language === "th" ? "" : ".str"});\n`;
    }
    else {
        if (lunrTokenizerSeparator) {
            generated += `\
lunr.tokenizer.separator = ${lunrTokenizerSeparator.toString()};\n`;
        }
        generated += `\
export const tokenize = (input) => lunr.tokenizer(input)
  .map(token => token.str);\n`;
    }
    generated += `export const mylunr = lunr;\n`;
    generated += `export const docsBasePath = ${JSON.stringify(docsBasePath)};\n`;
    generated += `export const blogBasePath = ${JSON.stringify(blogBasePath)};\n`;
    generated += `export const indexDocSidebarParentCategories = ${JSON.stringify(indexDocSidebarParentCategories)};\n`;
    ["src", "lib"].forEach((folder) => {
        const generatedPath = path_1.default.join(__dirname, "..", "..", folder, "client", "theme", "SearchBar", "generated.js");
        fs_1.default.writeFileSync(generatedPath, generated);
    });
    return {
        name: "@cmfcmf/docusaurus-search-local",
        getThemePath() {
            return path_1.default.resolve(__dirname, "..", "..", "lib", "client", "theme");
        },
        getTypeScriptThemePath() {
            return path_1.default.resolve(__dirname, "..", "..", "src", "client", "theme");
        },
        getDefaultCodeTranslationMessages: () => (0, utils_1.readDefaultCodeTranslationMessages)({
            dirPath: path_1.default.resolve(__dirname, "..", "..", "codeTranslations"),
            locale: context.i18n.currentLocale,
        }),
        async postBuild({ routesPaths = [], outDir, baseUrl, siteConfig: { trailingSlash }, }) {
            logger_1.default.info("Gathering documents");
            const data = routesPaths
                .flatMap((url) => {
                const route = url.substr(baseUrl.length);
                if (!url.startsWith(baseUrl)) {
                    throw new Error(`The route must start with the baseUrl ${baseUrl}, but was ${route}. This is a bug, please report it.`);
                }
                if (route === "404.html") {
                    // Do not index error page.
                    return [];
                }
                if (indexBlog && urlMatchesPrefix(route, blogBasePath)) {
                    if (route === blogBasePath ||
                        urlMatchesPrefix(route, `${blogBasePath}/tags`)) {
                        // Do not index list of blog posts and tags filter pages
                        return [];
                    }
                    return { route, url, type: "blog" };
                }
                if (indexDocs && urlMatchesPrefix(route, docsBasePath)) {
                    return { route, url, type: "docs" };
                }
                if (indexPages) {
                    return { route, url, type: "page" };
                }
                return [];
            })
                .map(({ route, url, type }) => {
                const file = trailingSlash === false
                    ? path_1.default.join(outDir, `${route}.html`)
                    : path_1.default.join(outDir, route, "index.html");
                return {
                    file,
                    url,
                    type,
                };
            });
            logger_1.default.info("Parsing documents");
            // Give every index entry a unique id so that the index does not need to store long URLs.
            let nextDocId = 1;
            const documents = (await Promise.all(data.map(async ({ file, url, type }) => {
                logger_1.default.debug(`Parsing ${type} file ${file}`, { url });
                const html = await readFileAsync(file, { encoding: "utf8" });
                const { pageTitle, sections, docSidebarParentCategories } = (0, parse_1.html2text)(html, type, url);
                const docVersion = (0, parse_1.getDocVersion)(html);
                return sections.map((section) => ({
                    id: nextDocId++,
                    pageTitle,
                    pageRoute: url,
                    sectionRoute: url + section.hash,
                    sectionTitle: section.title,
                    sectionContent: section.content,
                    docVersion,
                    docSidebarParentCategories,
                }));
            }))).flat();
            logger_1.default.info("Building index");
            const index = (0, lunr_1.default)(function () {
                if (language !== "en") {
                    if (Array.isArray(language)) {
                        // @ts-expect-error
                        this.use(lunr_1.default.multiLanguage(...language));
                    }
                    else {
                        // @ts-expect-error
                        this.use(lunr_1.default[language]);
                    }
                }
                this.ref("id");
                this.field("title");
                this.field("content");
                if (useDocVersioning) {
                    this.field("version");
                }
                if (indexDocSidebarParentCategories > 0) {
                    this.field("sidebarParentCategories");
                }
                const that = this;
                documents.forEach(function ({ id, sectionTitle, sectionContent, docVersion, docSidebarParentCategories, }) {
                    let sidebarParentCategories;
                    if (indexDocSidebarParentCategories > 0 &&
                        docSidebarParentCategories) {
                        sidebarParentCategories = docSidebarParentCategories
                            .reverse()
                            .slice(0, indexDocSidebarParentCategories)
                            .join(" ");
                    }
                    that.add({
                        id: id.toString(),
                        title: sectionTitle,
                        content: sectionContent,
                        version: docVersion,
                        sidebarParentCategories: sidebarParentCategories,
                    });
                });
            });
            logger_1.default.info("Writing index to disk");
            await writeFileAsync(path_1.default.join(outDir, "search-index.json"), JSON.stringify({
                documents: documents.map(({ id, pageTitle, sectionTitle, sectionRoute, docVersion }) => ({
                    id,
                    pageTitle,
                    sectionTitle,
                    sectionRoute,
                    // Only include docVersion metadata if versioning is used
                    docVersion: useDocVersioning ? docVersion : undefined,
                })),
                index,
            }), { encoding: "utf8" });
            logger_1.default.info("Index written to disk, success!");
        },
    };
}
exports.default = cmfcmfDocusaurusSearchLocal;
function validateOptions({ options, validate, }) {
    return validate(optionsSchema, options);
}
exports.validateOptions = validateOptions;
